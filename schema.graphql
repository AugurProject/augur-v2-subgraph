enum MarketStatus {
  TRADING
  REPORTING
  DISPUTING
  FINALIZED
  SETTLED
}

enum MarketType {
  YES_NO
  CATEGORICAL
  SCALAR
}

enum TokenType {
  REPUTATION_TOKEN
  DISPUTE_CROWDSOURCER
  PARTICIPATION_TOKEN
}

type User @entity {
  id: ID!

  userTokenBalances: [UserTokenBalance!]! @derivedFrom(field: "user")

  marketsCreated: [Market!]! @derivedFrom(field: "creator")

  marketsAsReporter: [Market!]! @derivedFrom(field: "designatedReporter")

  shareTokens: [ShareToken!]! @derivedFrom(field: "owner")
}

type Universe @entity {
  id: ID!

  parentUniverse: Universe

  payoutNumerators: [BigInt!]

  "Universe creation timestamp"
  creationTimestamp: BigInt

  "Latest universal value for the noShowBond charged on market creation"
  noShowBond: BigInt

  "Latest universal value for the validityBond charged on market creation"
  validityBond: BigInt

  "Latest universal value for the reporting fee charged on settlements"
  reportingFee: BigInt

  "Latest universal value for the value a designated reported is required to stake on the initial report"
  designatedReportStake: BigInt

  "Latest warpSync file hash"
  warpSyncHash: BigInt

  markets: [Market!]! @derivedFrom(field: "universe")

  children: [Universe!]! @derivedFrom(field: "parentUniverse")
}

type Market @entity {
  id: ID!

  universe: Universe!

  creator: User!

  owner: User!

  "Extra information in JSON format"
  extraInfo: String!

  "Number of Ticks in a complete set"
  numTicks: BigInt!

  "Designated user that should report the "
  designatedReporter: User!

  "Timestamp depicting the end of the real world event for that market"
  endTimestamp: BigInt!

  prices: [BigInt!]!

  marketTypeRaw: Int!

  marketType: MarketType!

  outcomes: [Bytes!]!

  "Creation timestamp"
  timestamp: BigInt!

  "NoShowBond payed on creation"
  noShowBond: BigInt!

  "Current status of the market"
  status: MarketStatus!

  openInterest: BigInt

  events: [MarketEvent!]! @derivedFrom(field: "market")

  shareTokens: [ShareToken!]! @derivedFrom(field: "market")
}

interface MarketEvent {
  id: ID!

  market: Market!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!
}

type TransferMarketEvent implements MarketEvent @entity {
  id: ID!

  market: Market!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  universe: Universe!

  from: User!

  to: User!
}

type MigrateMarketEvent implements MarketEvent @entity {
  id: ID!

  market: Market!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  originalUniverse: Universe!

  newUniverse: Universe!
}

type CreateMarketEvent implements MarketEvent @entity {
  id: ID!

  market: Market!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  universe: Universe!

  endTime: BigInt!

  extraInfo: String!

  marketCreator: User!

  designatedReporter: User!

  feePerCashInAttoCash: BigInt!

  prices: [BigInt!]!

  marketTypeRaw: Int!

  marketType: MarketType!

  numTicks: BigInt!

  outcomes: [Bytes!]!

  noShowBond: BigInt!

  creationTimestamp: BigInt!
}

type FinalizeMarketEvent implements MarketEvent @entity {
  id: ID!

  market: Market!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  finalizeTimestamp: BigInt!

  winningPayoutNumerators: [BigInt!]!
}

type OIChangeMarketEvent implements MarketEvent @entity {
  id: ID!

  market: Market!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  openInterest: BigInt!
}

type ShareToken @entity {
  id: ID!

  owner: User!

  balance: BigInt!

  outcome: BigInt!

  market: Market!
}

interface TokenEvent {
  id: ID!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  universe: Universe!

  token: Token!

  userTokenBalance: UserTokenBalance!

  amount: BigInt!
}

type TokenMintedEvent implements TokenEvent @entity {
  id: ID!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  universe: Universe!

  token: Token!

  userTokenBalance: UserTokenBalance!

  amount: BigInt!
}

type TokenBurnedEvent implements TokenEvent @entity {
  id: ID!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  universe: Universe!

  token: Token!

  userTokenBalance: UserTokenBalance!

  amount: BigInt!
}

type TokenTransferredEvent implements TokenEvent @entity {
  id: ID!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  universe: Universe!

  token: Token!

  userTokenBalance: UserTokenBalance!

  amount: BigInt!

  from: User!

  to: User!

  "In any transfer there will be 2 entities generated since you will have a sender and receiver. The related event is the other event generated for this transfer"
  relatedEvent: TokenTransferredEvent!

  "Depicts whether the user for this event is the sender or receiver"
  isSender: Boolean!
}

interface UserTokenBalance {
  id: ID!

  universe: Universe!

  user: User!

  token: Token!

  balance: BigInt!

  events: [TokenEvent!]! @derivedFrom(field: "userTokenBalance")
}

type UserReputationTokenBalance implements UserTokenBalance @entity {
  id: ID!

  universe: Universe!

  user: User!

  token: Token!

  balance: BigInt!

  events: [TokenEvent!]! @derivedFrom(field: "userTokenBalance")
}

type UserDisputeTokenBalance implements UserTokenBalance @entity {
  id: ID!

  universe: Universe!

  user: User!

  market: Market!

  outcome: BigInt!

  token: Token!

  balance: BigInt!

  events: [TokenEvent!]! @derivedFrom(field: "userTokenBalance")
}

type UserParticipationTokenBalance implements UserTokenBalance @entity {
  id: ID!

  universe: Universe!

  user: User!

  token: Token!

  balance: BigInt!

  events: [TokenEvent!]! @derivedFrom(field: "userTokenBalance")
}

type Token @entity {
  id: ID!

  universe: Universe!

  tokenType: TokenType!

  userBalances: [UserTokenBalance!]! @derivedFrom(field: "token")
}
