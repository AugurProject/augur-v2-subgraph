enum MarketStatus {
  TRADING
  REPORTING
  DISPUTING
  FINALIZED
  SETTLED
}

enum MarketType {
  YES_NO
  CATEGORICAL
  SCALAR
}

enum TokenType {
  REPUTATION_TOKEN
  DISPUTE_CROWDSOURCER
  PARTICIPATION_TOKEN
}

type User @entity {
  id: ID!

  userTokenBalances: [UserTokenBalance!]! @derivedFrom(field: "user")

  marketsCreated: [Market!]! @derivedFrom(field: "creator")

  marketsAsReporter: [Market!]! @derivedFrom(field: "designatedReporter")

  shareTokens: [ShareToken!]! @derivedFrom(field: "owner")
}

type Universe @entity {
  id: ID!

  parentUniverse: Universe

  payoutNumerators: [BigInt!]

  "Universe creation timestamp"
  creationTimestamp: BigInt

  "Latest universal value for the noShowBond charged on market creation"
  noShowBond: BigInt

  "Latest universal value for the validityBond charged on market creation"
  validityBond: BigInt

  "Latest universal value for the reporting fee charged on settlements"
  reportingFee: BigInt

  "Latest universal value for the value a designated reported is required to stake on the initial report"
  designatedReportStake: BigInt

  "Latest warpSync file hash"
  warpSyncHash: BigInt

  markets: [Market!]! @derivedFrom(field: "universe")

  children: [Universe!]! @derivedFrom(field: "parentUniverse")
}

type Market @entity {
  id: ID!

  universe: Universe!

  creator: User!

  owner: User!

  "Extra information in JSON format"
  extraInfo: String!

  "Number of Ticks in a complete set"
  numTicks: BigInt!

  "Designated user that should report the "
  designatedReporter: User!

  "Timestamp depicting the end of the real world event for that market"
  endTimestamp: BigInt!

  prices: [BigInt!]!

  marketTypeRaw: Int!

  marketType: MarketType!

  outcomes: [Bytes!]!

  numOutcomes: Int!

  "Creation timestamp"
  timestamp: BigInt!

  "NoShowBond payed on creation"
  noShowBond: BigInt!

  "Current status of the market"
  status: MarketStatus!

  openInterest: BigInt

  report: MarketReport

  events: [MarketEvent!]! @derivedFrom(field: "market")

  shareTokens: [ShareToken!]! @derivedFrom(field: "market")

  dispute: Dispute
}

interface MarketEvent {
  id: ID!

  market: Market!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!
}

type TransferMarketEvent implements MarketEvent @entity {
  id: ID!

  market: Market!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  universe: Universe!

  from: User!

  to: User!
}

type MigrateMarketEvent implements MarketEvent @entity {
  id: ID!

  market: Market!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  originalUniverse: Universe!

  newUniverse: Universe!
}

type CreateMarketEvent implements MarketEvent @entity {
  id: ID!

  market: Market!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  universe: Universe!

  endTime: BigInt!

  extraInfo: String!

  marketCreator: User!

  designatedReporter: User!

  feePerCashInAttoCash: BigInt!

  prices: [BigInt!]!

  marketTypeRaw: Int!

  marketType: MarketType!

  numTicks: BigInt!

  outcomes: [Bytes!]!

  noShowBond: BigInt!

  creationTimestamp: BigInt!
}

type FinalizeMarketEvent implements MarketEvent @entity {
  id: ID!

  market: Market!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  finalizeTimestamp: BigInt!

  winningPayoutNumerators: [BigInt!]!
}

type OIChangeMarketEvent implements MarketEvent @entity {
  id: ID!

  market: Market!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  openInterest: BigInt!
}

type ShareToken @entity {
  id: ID!

  owner: User!

  balance: BigInt!

  outcome: BigInt!

  market: Market!
}

interface TokenEvent {
  id: ID!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  universe: Universe!

  token: Token!

  userTokenBalance: UserTokenBalance!

  amount: BigInt!
}

type TokenMintedEvent implements TokenEvent @entity {
  id: ID!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  universe: Universe!

  token: Token!

  userTokenBalance: UserTokenBalance!

  amount: BigInt!
}

type TokenBurnedEvent implements TokenEvent @entity {
  id: ID!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  universe: Universe!

  token: Token!

  userTokenBalance: UserTokenBalance!

  amount: BigInt!
}

type TokenTransferredEvent implements TokenEvent @entity {
  id: ID!

  timestamp: BigInt!

  block: BigInt!

  tx_hash: String!

  universe: Universe!

  token: Token!

  userTokenBalance: UserTokenBalance!

  amount: BigInt!

  from: User!

  to: User!

  "In any transfer there will be 2 entities generated since you will have a sender and receiver. The related event is the other event generated for this transfer"
  relatedEvent: TokenTransferredEvent!

  "Depicts whether the user for this event is the sender or receiver"
  isSender: Boolean!
}

interface UserTokenBalance {
  id: ID!

  universe: Universe!

  user: User!

  token: Token!

  balance: BigInt!

  events: [TokenEvent!]! @derivedFrom(field: "userTokenBalance")
}

type UserReputationTokenBalance implements UserTokenBalance @entity {
  id: ID!

  universe: Universe!

  user: User!

  token: Token!

  balance: BigInt!

  events: [TokenEvent!]! @derivedFrom(field: "userTokenBalance")
}

type UserDisputeTokenBalance implements UserTokenBalance @entity {
  id: ID!

  universe: Universe!

  user: User!

  market: Market!

  outcome: BigInt!

  token: Token!

  balance: BigInt!

  events: [TokenEvent!]! @derivedFrom(field: "userTokenBalance")
}

type UserParticipationTokenBalance implements UserTokenBalance @entity {
  id: ID!

  universe: Universe!

  user: User!

  token: Token!

  balance: BigInt!

  events: [TokenEvent!]! @derivedFrom(field: "userTokenBalance")
}

type Token @entity {
  id: ID!

  universe: Universe!

  tokenType: TokenType!

  userBalances: [UserTokenBalance!]! @derivedFrom(field: "token")
}

type MarketReport @entity {
  id: ID!

  market: Market!

  "Current payout numerators reported. This essentially represents the current tentative outcome but expressed as a payout set"
  payoutNumerators: [BigInt!]!

  "User that first reported the market result"
  initialReporter: User!

  "Whether the first reporter was the designated reporter or not"
  isDesignatedReporter: Boolean!

  "Whether the current report state is the initial report."
  isInitialReport: Boolean!

  "Whether the current report is final and won't be subject to change because of challenges"
  isFinal: Boolean!

  lastReportedAt: BigInt!

  firstReportedAt: BigInt!
}

type Dispute @entity {
  id: ID!

  "Updated report for the market"
  currentReport: MarketReport!

  currentDisputeRound: DisputeRound!

  market: Market!

  universe: Universe!

  "Depicts whether the dispute is completed or not. It will be done once the market has finalized because the tentative outcome hasn't been challenged in a whole dispute window"
  isDone: Boolean!

  rounds: [DisputeRound!]! @derivedFrom(field: "dispute")

  creationTimestamp: BigInt!

  block: BigInt!

  tx_hash: String!
}

type DisputeWindow @entity {
  id: ID!

  universe: Universe!

  startTime: BigInt!

  endTime: BigInt!
}

type DisputeRound @entity {
  id: ID!

  dispute: Dispute!

  market: Market!

  universe: Universe!

  crowdsourcers: [DisputeCrowdsourcer!]! @derivedFrom(field: "disputeRound")
}

type DisputeCrowdsourcer @entity {
  id: ID!

  market: Market!

  universe: Universe!

  "Payout numerators depict all the outcomes and their respective 'share' of the winnings based on the numTick of the market"
  payoutNumerators: [BigInt!]!

  "Amount of attoREP staked"
  staked: BigInt!

  "Amount of attoREP needed for the dispute bond to be filled and challenge/dispute the current tentative report"
  disputeBondSize: BigInt!

  "Whether the bond has been filled or not"
  bondFilled: Boolean!

  disputeRound: DisputeRound!
}

# it would be good to create entities out of outcomes...
